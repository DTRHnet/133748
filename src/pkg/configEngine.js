import fs from 'fs';
import path from 'path';
import { PATHS, APP_INFO } from './constants.js';
import { info, debug, warn, error } from './logger.js';

class ConfigEngine {
  constructor() {
    this.config = {};
    this.configPath = this.resolveConfigPath();
    this.defaultConfigContent = this.getDefaultConfigContent();
  }

  /**
   * Resolves the effective configuration file path based on CLI, env, or default.
   * @returns {string} The full path to the configuration file.
   */
  resolveConfigPath() {
    // Priority: CLI arg (--config), Environment variable (133748_CONF), Default path
    const cliConfigPath = process.argv.find((arg) => arg.startsWith('--config='));
    if (cliConfigPath) {
      return path.resolve(process.cwd(), cliConfigPath.split('=')[1]);
    }

    if (process.env.LEETAB_CONF) {
      // Using LEETAB_CONF for consistency with project name play
      return path.resolve(process.env.LEETAB_CONF);
    }

    return path.join(PATHS.CONFIG_DIR, PATHS.DEFAULT_CONFIG_FILE_NAME);
  }

  /**
   * Generates the default configuration content as a string.
   * @returns {string} The default config content.
   */
  // ... (existing imports and class structure)

  getDefaultConfigContent() {
    return `
# ${APP_INFO.NAME} Configuration File
# This file is automatically generated. Modify with care.

# --- General Settings ---
# Directory where downloaded tabs will be saved.
tabs_dir = ${PATHS.DEFAULT_TABS_DIR}

# Directory for application logs.
log_dir = ${PATHS.DEFAULT_LOG_DIR}

# Log level for console and file output (debug, info, warn, error, silent).
# Set to 'debug' for verbose output explaining the process
log_level = debug

# --- Scraper Settings ---
# Maximum number of concurrent downloads.
concurrent_downloads = 3

# Timeout for network requests in milliseconds.
request_timeout_ms = 15000

# Delay between fetching successive search result pages in milliseconds.
page_delay_ms = 1000

# Maximum number of search result pages to fetch during a search operation.
max_search_pages = 10

# Minimum number of results expected on a page after the first to continue pagination.
# If fewer than this, it might indicate the end of relevant results.
min_results_per_page_threshold = 5

# Path to a specific Chrome/Chromium executable (optional).
# chrome_path = /usr/bin/google-chrome-stable

# --- FZF / TUI Settings ---
# Should the TUI automatically launch if no command is given? (true/false)
auto_launch_tui = false

# --- Development / Internal ---
# Directory for temporary files.
tmp_dir = ${PATHS.DEFAULT_TMP_DIR}
`.trim();
  }

  /**
   * Parses a single line of config (key=value # comment).
   * @param {string} line - A line from the config file.
   * @returns {[string, string]|null} [key, value] or null if invalid.
   */
  parseLine(line) {
    const trimmedLine = line.trim();
    if (!trimmedLine || trimmedLine.startsWith('#')) {
      return null; // Skip empty lines and comments
    }

    const [keyPart, ...valueParts] = trimmedLine.split('=');
    const key = keyPart.trim();
    if (!key) {
      return null; // Key cannot be empty
    }

    let value = valueParts.join('=').trim();
    // Remove inline comments
    const commentIndex = value.indexOf('#');
    if (commentIndex !== -1) {
      value = value.substring(0, commentIndex).trim();
    }

    return [key, value];
  }

  /**
   * Loads configuration from the determined config file.
   * Creates the file with default content if it doesn't exist.
   */
  loadConfig() {
    const configDir = path.dirname(this.configPath);
    if (!fs.existsSync(configDir)) {
      debug(`📁 Creating config directory: ${configDir}`);
      fs.mkdirSync(configDir, { recursive: true });
      debug(`✓ Config directory created`);
    }

    if (!fs.existsSync(this.configPath)) {
      info(`ℹ️  Config file not found at ${this.configPath}`);
      info(`📝 Creating default configuration file...`);
      fs.writeFileSync(this.configPath, this.defaultConfigContent);
      info(`✓ Default config file created`);
    }

    try {
      debug(`📖 Reading config from: ${this.configPath}`);
      const fileContent = fs.readFileSync(this.configPath, 'utf8');
      const lines = fileContent.split('\n');
      const newConfig = {};
      let parsedKeys = 0;

      for (const line of lines) {
        const parsed = this.parseLine(line);
        if (parsed) {
          const [key, value] = parsed;
          newConfig[key] = value;
          parsedKeys++;
        }
      }
      this.config = newConfig;
      debug(`✓ Configuration loaded: ${parsedKeys} settings found`);
    } catch (e) {
      error(`❌ Failed to load configuration from ${this.configPath}: ${e.message}`);
      warn('⚠️  Proceeding with default or in-memory settings.');
      this.config = {}; // Fallback to empty or existing in-memory if loading fails
    }
  }

  /**
   * Gets a configuration value.
   * @param {string} key - The configuration key.
   * @param {*} [defaultValue] - Value to return if key is not found.
   * @returns {*} The configuration value.
   */
  get(key, defaultValue = undefined) {
    const value = this.config[key];
    if (value === undefined) {
      debug(`Config key "${key}" not found. Returning default: ${defaultValue}`);
      return defaultValue;
    }
    // Simple type coercion for common types (string is default)
    if (value.toLowerCase() === 'true') return true;
    if (value.toLowerCase() === 'false') return false;
    if (!isNaN(Number(value)) && !isNaN(parseFloat(value))) return Number(value); // Convert to number if it's a valid number
    return value;
  }

  /**
   * Sets a configuration value and persists it to the file.
   * @param {string} key - The configuration key.
   * @param {string} value - The value to set.
   */
  set(key, value) {
    this.config[key] = String(value); // Store all values as strings internally

    try {
      const lines = fs.readFileSync(this.configPath, 'utf8').split('\n');
      let found = false;
      const updatedLines = lines.map((line) => {
        const parsed = this.parseLine(line);
        if (parsed && parsed[0] === key) {
          found = true;
          return `${key} = ${value}`;
        }
        return line;
      });

      if (!found) {
        updatedLines.push(`${key} = ${value}`); // Add if key not found
      }

      fs.writeFileSync(this.configPath, updatedLines.join('\n'), 'utf8');
      info(`Configuration key "${key}" set to "${value}" in ${this.configPath}`);
    } catch (e) {
      error(`Failed to set configuration key "${key}" to "${value}": ${e.message}`);
      debug(e.stack);
    }
  }

  /**
   * Deletes a configuration key from the file.
   * @param {string} key - The key to delete.
   */
  unset(key) {
    if (!this.config[key]) {
      warn(`Configuration key "${key}" not found. No action taken.`);
      return;
    }

    try {
      const lines = fs.readFileSync(this.configPath, 'utf8').split('\n');
      const updatedLines = lines.filter((line) => {
        const parsed = this.parseLine(line);
        return !(parsed && parsed[0] === key);
      });

      fs.writeFileSync(this.configPath, updatedLines.join('\n'), 'utf8');
      delete this.config[key]; // Remove from in-memory config
      info(`Configuration key "${key}" removed from ${this.configPath}`);
    } catch (e) {
      error(`Failed to remove configuration key "${key}": ${e.message}`);
      debug(e.stack);
    }
  }

  /**
   * Lists all current configuration settings.
   * @returns {Object} An object representing the current configuration.
   */
  list() {
    return { ...this.config }; // Return a copy
  }

  /**
   * Returns the path to the current config file.
   * @returns {string} The path to the config file.
   */
  getConfigFilePath() {
    return this.configPath;
  }
}

export const configEngine = new ConfigEngine();
